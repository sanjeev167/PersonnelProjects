/**
 * 
 */
package com.admin.pub.local_en.service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.servlet.ServletContext;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.User.UserBuilder;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.admin.pvt.menu_mgr.dto.MenuDTO;
import com.admin.pvt.menu_mgr.entity.TreeMenuTypeMaster;
import com.admin.pvt.menu_mgr.repo.TreeMenuTypeMasterRepository;
import com.admin.pvt.menu_mgr.service.MenuManagerService;
import com.admin.pvt.sec.rbac.entity.UserReg;
import com.admin.pvt.sec.rbac.repo.AppAdminUserRepository;
import com.custom.exception.CustomRuntimeException;

/**
 * @author Sanjeev
 *
 */

@Service
public class CustomAdministrativeUserDetailsServiceImpl implements UserDetailsService {

	@Autowired
	private AppAdminUserRepository appAdminUserRepository;

	@Autowired
	ServletContext servletContext;
	
	

	@Autowired
	MenuManagerService menuManagerService;

	@Autowired
	TreeMenuTypeMasterRepository treeMenuTypeMasterRepository;

	private ArrayList<MenuDTO> vMenuCollection=new ArrayList<MenuDTO>();

	@Transactional
	@Override
	public UserDetails loadUserByUsername(String email) {

		UserReg userReg = appAdminUserRepository.findByEmail(email).get();
		CustomAdministrativeUserDetailsImpl customAdministrativeUserDetailsImpl = new CustomAdministrativeUserDetailsImpl();
		UserBuilder builder = null;
		if (userReg != null) {
			builder = org.springframework.security.core.userdetails.User.withUsername(email);
			builder.password(new BCryptPasswordEncoder().encode(userReg.getPassword()));
			builder.authorities(customAdministrativeUserDetailsImpl.getAuthorities(userReg));
			try {
				prepareMenuListForLoggedInUser((List<SimpleGrantedAuthority>) customAdministrativeUserDetailsImpl.getAuthorities(userReg));
			} catch (CustomRuntimeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} else {
			throw new UsernameNotFoundException("User not found.");
		}
		return builder.build();
	}

	private void prepareMenuListForLoggedInUser(List<SimpleGrantedAuthority> simpleGrantedAuthorityList)
			throws CustomRuntimeException {
		// TODO Auto-generated method stub
		Map<String, Map<String, List<MenuDTO>>> roleWiseMenuCollectionMap = (Map<String, Map<String, List<MenuDTO>>>) context
				.getAttribute("RoleWiseMenuCollectionMap");
		
		Map<String, List<MenuDTO>> treeTypeWiseMenuCollectionMap = null;
		
		List<MenuDTO> menuDTOListForAllRolesForAUser = new ArrayList<MenuDTO>();
		
		String role = "";
		for (SimpleGrantedAuthority simpleGrantedAuthority : simpleGrantedAuthorityList) {
			// Take out role one by one
			role = simpleGrantedAuthority.getAuthority();
			// Take out all tree type menu collection for this role
			System.out.println("Coming role = "+role);
			treeTypeWiseMenuCollectionMap = roleWiseMenuCollectionMap.get("SUPER_ADMIN");// Fetch all tree type wise menu
			System.out.println("treeTypeWiseMenuCollectionMap = "+treeTypeWiseMenuCollectionMap);																	// collection
			// Now take out each menu type menuDTOList
			String treeTypeName;
			for (Entry<String, List<MenuDTO>> treeTypeMenuEntryForARole : treeTypeWiseMenuCollectionMap.entrySet()) {
				treeTypeName = treeTypeMenuEntryForARole.getKey();
				// Take out tree type menu id using tree type name
				List<TreeMenuTypeMaster> treeMenuTypeMasterList = treeMenuTypeMasterRepository.findAll();
				int id = 0;
				for (TreeMenuTypeMaster treeMenuTypeMaster : treeMenuTypeMasterList) {
					if (treeMenuTypeMaster.getName().equals(treeTypeName)) {
						id = treeMenuTypeMaster.getId();
					}
				}
				ArrayList<MenuDTO> menuDTOListDefinedForARole = (ArrayList<MenuDTO>) treeTypeMenuEntryForARole.getValue();
				  // Take out complete vertical tree menu structure available in the system
				ArrayList<MenuDTO> menuDTOListAvailableInSystem = menuManagerService.getSpecificTreeTypeStructure(id);
				// Now start collecting those tree structure which is allowed for this role.
			   // For doing so, we simply pick that menDTO from the existing tree list which is
			  // allowed for this role
			 // Collect it into a list.
				for (MenuDTO menuDTODefinedForRole : menuDTOListDefinedForARole) {
					for (MenuDTO menuDTOAvailable : menuDTOListAvailableInSystem) {
						
						if (menuDTOAvailable.getId().equals(menuDTODefinedForRole.getId())) {
							// if matched, collect it in an array list
							System.out.println("menuDTOAvailable.getId() ="+menuDTOAvailable.getId());
							System.out.println("menuDTODefinedForRole.getId() ="+menuDTODefinedForRole.getId());
							vMenuCollection.add(menuDTOAvailable);
						}
					}
				}
			}
		}
		
		/////////////
		int i = 1;
		for (MenuDTO menuDTO : vMenuCollection) {						
			System.out.println("\t\t [" + (i++) + "]");
			System.out.println("\t\t\tNode Type = " + menuDTO.getNodeType());
			System.out.println("\t\t\tParent Node ID = " + menuDTO.getParent_id());
			System.out.println("\t\t\tNode Id = " + menuDTO.getId());
			System.out.println("\t\t\tNode Name = " + menuDTO.getName());
			System.out.println("\t\t\tUrl = " + menuDTO.getLeafUrl());
			System.out.println("\t\t\tImage Url = " + menuDTO.getNodeImgUrl());
		} // Tree node or leaf level looping
		
		///////////////
	}//End of prepareMenuListForLoggedInUser
	
	ArrayList<String> finalHierarchicalRoleCollection=new ArrayList<String>();
	private List<MenuDTO> findAllRolesDefinedForARoleInHierarchy(String role ){		
		Map<String, Map<String, List<MenuDTO>>> definedRoleHierarchyMap=(Map<String, Map<String, List<MenuDTO>>>) servletContext.getAttribute("RoleWiseMenuCollectionMap");
	
		//First find all roles dependent on a role
		//Collect role and dependent roles in a collection
		//Then find all dependent roles of each dependent role
		//Keep looping as long as all dependent roles get exhausted
		//Now we have a collection of all roles dependencies in hierarchy
		Set<Entry<String, Map<String, List<MenuDTO>>>> definedRoleHierarchyMapEntrySet=definedRoleHierarchyMap.entrySet();
		for (Entry<String, Map<String, List<MenuDTO>>> dependentRoleHierarchyEntry : definedRoleHierarchyMapEntrySet) {
			String comingRoleForHierarcicalCollection=dependentRoleHierarchyEntry.getKey();
			if(comingRoleForHierarcicalCollection.equals(role))
			   finalHierarchicalRoleCollection.add(comingRoleForHierarcicalCollection);			  
			//Now take its all dependent roles
			Map<String, List<MenuDTO>> dependentRoleInHierarchyMap=dependentRoleHierarchyEntry.getValue();
			Set<Entry<String, List<MenuDTO>>> dependentRoleHierarchyEntrySet=dependentRoleInHierarchyMap.entrySet();			
			for(Entry<String, List<MenuDTO>> innerDependentRoleHierarchyEntry :dependentRoleHierarchyEntrySet) {				;
				finalHierarchicalRoleCollection.add(innerDependentRoleHierarchyEntry.getKey());
				//for each such dependent role , take out its dependent roles
				findAllRolesDefinedForARoleInHierarchy(innerDependentRoleHierarchyEntry.getKey());
			}
			
		}
		
		
	    return this.findAllRolesDefinedForARoleInHierarchy;
	}//End of findAllRolesDefinedForARoleInHierarchy
	
	
	
	//Map<String, Map<String, List<MenuDTO>>>

	/**
	 * @return the vMenuCollection
	 */
	public ArrayList<MenuDTO> getvMenuCollection() {
		return vMenuCollection;
	}

	/**
	 * @param vMenuCollection the vMenuCollection to set
	 */
	public void setvMenuCollection(ArrayList<MenuDTO> vMenuCollection) {
		this.vMenuCollection = vMenuCollection;
	}

}